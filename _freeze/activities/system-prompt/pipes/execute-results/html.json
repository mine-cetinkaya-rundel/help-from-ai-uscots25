{
  "hash": "8385b43963375a3ead24acba6d1e3ce7",
  "result": {
    "engine": "knitr",
    "markdown": "# Pipes\n\n## Introduction\n\nUse `|>` to emphasise a sequence of actions, rather than the object that the actions are being performed on.\n\nThe tidyverse has been designed to work particularly well with the pipe, but you can use it with any code, particularly in conjunction with the `_` placeholder.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstrings |>\n  str_replace(\"a\", \"b\") |>\n  str_replace(\"x\", \"y\")\n\nstrings |>\n  gsub(\"a\", \"b\", x = _) |>\n  gsub(\"x\", \"y\", x = _)\n```\n:::\n\n\nAvoid using the pipe when:\n\n* You need to manipulate more than one object at a time. Reserve pipes for a\n  sequence of steps applied to one primary object.\n\n* There are meaningful intermediate objects that could be given\n  informative names.\n\n## Whitespace\n\n`|>` should always have a space before it, and should usually be followed by a new line. After the first step, each line should be indented by two spaces. This structure makes it easier to add new steps (or rearrange existing steps) and harder to overlook a step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\niris |>\n  summarize(across(where(is.numeric), mean), .by = Species) |>\n  pivot_longer(!Species, names_to = \"measure\", values_to = \"value\") |>\n  arrange(value)\n\n# Bad\niris |> summarize(across(where(is.numeric), mean), .by = Species) |>\npivot_longer(!Species, names_to = \"measure\", values_to = \"value\") |>\narrange(value)\n```\n:::\n\n\n## Long lines\n\nIf the arguments to a function don't all fit on one line, put each argument on\nits own line and indent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\niris |>\n  summarise(\n    Sepal.Length = mean(Sepal.Length),\n    Sepal.Width = mean(Sepal.Width),\n    .by = Species\n  )\n\n# Bad\niris |>\n  summarise(Sepal.Length = mean(Sepal.Length), Sepal.Width = mean(Sepal.Width), .by = Species)\n```\n:::\n\n\nFor data analysis, we recommend using the pipe whenever a function needs to span multiple lines, even if it's only a single step.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Bad\nsummarise(\n  iris,\n  Sepal.Length = mean(Sepal.Length),\n  Sepal.Width = mean(Sepal.Width),\n  .by = Species\n)\n```\n:::\n\n\n## Short pipes\n\nIt's ok to write a short pipe on a single line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ok\niris |> subset(Species == \"virginica\") |> _$Sepal.Length\niris |> summarise(width = Sepal.Width, .by = Species) |> arrange(width)\n```\n:::\n\n\nBut because short pipes often become longer pipes, we recommend that you generally stick to one function per line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Better\niris |>\n  subset(Species == \"virginica\") |>\n  _$Sepal.Length\n\niris |>\n  summarise(width = Sepal.Width, .by = Species) |>\n  arrange(width)\n```\n:::\n\n\nSometimes it's useful to include a short pipe as an argument to a function in a\nlonger pipe. Carefully consider whether the code is more readable with a short\ninline pipe (which doesn't require a lookup elsewhere) or if it's better to move\nthe code outside the pipe and give it an evocative name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\nx |>\n  semi_join(y |> filter(is_valid))\n\n# Ok\nx |>\n  select(a, b, w) |>\n  left_join(y |> select(a, b, v), join_by(a, b))\n\n# Better\nx_join <- x |> select(a, b, w)\ny_join <- y |> select(a, b, v)\nleft_join(x_join, y_join, join_by(a, b))\n```\n:::\n\n\n## Assignment\n\nThere are three acceptable forms of assignment:\n\n*   Variable name and assignment on separate lines:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iris_long <-\n      iris |>\n      gather(measure, value, -Species) |>\n      arrange(-value)\n    ```\n    :::\n\n\n*   Variable name and assignment on the same line:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iris_long <- iris |>\n      gather(measure, value, -Species) |>\n      arrange(-value)\n    ```\n    :::\n\n\n*   Assignment at the end of the pipe with `->`:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    iris |>\n      gather(measure, value, -Species) |>\n      arrange(-value) ->\n      iris_long\n    ```\n    :::\n\n\nI think that the third is the most natural to write, but makes reading a little\nharder: when the name comes first, it can act as a heading to remind\nyou of the purpose of the pipe.\n\n## magrittr\n\nWe recommend you use the base `|>` pipe instead of magrittr's `%>%`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Good\niris |>\n  summarise(width = Sepal.Width, .by = Species) |>\n  arrange(width)\n\n# Bad\niris %>%\n  summarise(width = Sepal.Width, .by = Species) %>%\n  arrange(width)\n```\n:::\n\n\nAs of R 4.3.0, the base pipe provides all the features from magrittr that we recommend using.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}